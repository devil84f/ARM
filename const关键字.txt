在C语言中，`const` 关键字与指针结合使用时，其位置不同会导致语义的显著差异。以下是针对 **指针与 `const`** 的详细解释，包括每种情况的语法、作用、示例和注意事项。

---

### **2.1 指向常量的指针（指针指向的内容不可变）**
#### **语法：**
```c
const 类型 *指针名;  // 或等价写法：类型 const *指针名;
```
#### **作用：**
- 指针本身可以修改（指向其他地址），但**不能通过该指针修改它指向的值**。
- 被指向的变量本身不一定是常量（可能通过其他方式修改）。

#### **示例：**
```c
int x = 10;
const int *ptr = &x;  // ptr指向x，但通过ptr不能修改x

// *ptr = 20;        // 错误：编译时报错，不能通过ptr修改x
x = 20;              // 合法：x本身不是const，可直接修改
ptr = &y;            // 合法：ptr可以指向其他变量
```

#### **典型用途：**
- 函数参数中保护数据不被意外修改：
  ```c
  void print(const char *str) {
      // str[0] = 'A';  // 错误：str指向的内容被视为只读
      printf("%s\n", str);
  }
  ```

---

### **2.2 常量指针（指针本身不可变，指向的内容可变）**
#### **语法：**
```c
类型 *const 指针名;
```
#### **作用：**
- 指针的**指向不可变**（必须初始化且不能指向其他地址），但**可以通过指针修改它指向的值**。
- 被指向的变量本身不需要是常量。

#### **示例：**
```c
int a = 5, b = 6;
int *const ptr = &a;  // ptr初始化后只能指向a

*ptr = 10;            // 合法：可以修改a的值
// ptr = &b;          // 错误：ptr的指向不可变
a = 20;               // 合法：a本身仍可变
```

#### **典型用途：**
- 固定指针的指向，防止指针被意外修改（如硬件寄存器操作）：
  ```c
  volatile int *const reg = (int*)0x1234;
  *reg = 1;  // 写入寄存器，但reg始终指向0x1234
  ```

---

### **2.3 指向常量的常量指针（指针和内容均不可变）**
#### **语法：**
```c
const 类型 *const 指针名;
```
#### **作用：**
- 指针**不能指向其他地址**，也**不能通过指针修改它指向的值**。
- 被指向的变量本身可能是常量或非常量（但无论如何都无法通过该指针修改）。

#### **示例：**
```c
int x = 100;
const int *const ptr = &x;  // ptr只能指向x，且不能通过ptr修改x

// *ptr = 200;      // 错误：不能通过ptr修改x
// ptr = &y;        // 错误：ptr的指向不可变
x = 200;            // 合法：x本身不是const
```

#### **典型用途：**
- 定义只读的全局常量指针（如字符串字面量）：
  ```c
  const char *const ERROR_MSG = "Fatal error";
  // ERROR_MSG[0] = 'f';  // 错误
  // ERROR_MSG = "Oops";  // 错误
  ```

---

### **2.4 关键区别总结**
| 类型                | 指针本身是否可变 | 指向的内容是否可变 | 初始化要求         |
|---------------------|------------------|--------------------|--------------------|
| `const int *ptr`    | 是               | 否                 | 无需初始化         |
| `int *const ptr`    | 否               | 是                 | 必须初始化         |
| `const int *const ptr` | 否            | 否                 | 必须初始化         |

---

### **2.5 常见混淆与注意事项**
1. **`const` 的位置灵活性**：  
   - `const int *p` 和 `int const *p` 完全等价，均表示指向常量的指针。  
   - `int *const p` 必须将 `const` 放在 `*` 右侧，表示指针本身是常量。

2. **类型转换规则**：  
   - **安全转换**：非 `const` 指针可以隐式转为 `const` 指针（添加只读限制）。  
     ```c
     int *p;
     const int *cp = p;  // 合法
     ```
   - **危险转换**：`const` 指针转为非 `const` 指针需显式强制转换（可能引发未定义行为）。  
     ```c
     const int *cp;
     int *p = (int*)cp;  // 强制转换（慎用！）
     ```

3. **与字符串字面量**：  
   - 字符串字面量（如 `"hello"`）本质是 `const char[]`，若用非 `const` 指针指向它可能触发警告：  
     ```c
     char *s = "hello";  // 警告（应改为 const char*）
     // s[0] = 'H';      // 未定义行为（可能崩溃）
     ```

---

### **2.6 代码示例分析**
```c
#include <stdio.h>

int main() {
    int a = 1, b = 2;
    
    // 1. 指向常量的指针
    const int *ptr1 = &a;
    // *ptr1 = 10;      // 错误
    a = 10;             // 合法
    ptr1 = &b;          // 合法

    // 2. 常量指针
    int *const ptr2 = &a;
    *ptr2 = 20;         // 合法
    // ptr2 = &b;       // 错误

    // 3. 指向常量的常量指针
    const int *const ptr3 = &a;
    // *ptr3 = 30;      // 错误
    // ptr3 = &b;       // 错误
    a = 30;             // 合法

    return 0;
}
```

---

### **总结**
- **`const` 与指针的组合**通过限制指针或其所指内容的可变性，增强代码的安全性和可维护性。  
- 理解 `const` 的位置差异是关键：  
  - 左侧 `const`（如 `const int *`）：保护指向的数据。  
  - 右侧 `const`（如 `int *const`）：固定指针的指向。  
- 合理使用可避免意外修改，尤其在函数参数传递和硬件编程中。